const request = require('supertest');
const { app } = require('../../index');
const TokenManager = require('../../services/TokenManager');
const CacheManager = require('../../services/CacheManager');
const ExportService = require('../../services/ExportService');

jest.mock('../../services/TokenManager');
jest.mock('../../services/CacheManager');
jest.mock('../../services/ExportService');

describe('API Integration Tests', () => {
  let adminToken;
  let userToken;

  beforeAll(async () => {
    // Setup test tokens (in a real app, these would be generated by your auth service)
    adminToken = 'admin-test-token';
    userToken = 'user-test-token';
  });

  describe('Token Management Flow', () => {
    it('should handle complete token management flow', async () => {
      // 1. Get initial stats
      const statsResponse = await request(app)
        .get('/api/tokens/stats')
        .expect(200);

      expect(statsResponse.body).toHaveProperty('dailyUsage');
      expect(statsResponse.body).toHaveProperty('dailyLimit');

      // 2. Check token limits
      const checkResponse = await request(app)
        .post('/api/tokens/check')
        .send({ estimatedTokens: 100 })
        .expect(200);

      expect(checkResponse.body).toHaveProperty('allowed');
      expect(checkResponse.body).toHaveProperty('remaining');

      // 3. Try to reset as user (should fail)
      await request(app)
        .post('/api/tokens/reset')
        .set('Authorization', `Bearer ${userToken}`)
        .expect(403);

      // 4. Reset as admin
      await request(app)
        .post('/api/tokens/reset')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);
    });
  });

  describe('Cache Management Flow', () => {
    it('should handle complete cache management flow', async () => {
      // 1. Check cache health
      const healthResponse = await request(app)
        .get('/api/cache/health')
        .expect(200);

      expect(healthResponse.body).toHaveProperty('healthy');

      // 2. Get cache stats
      const statsResponse = await request(app)
        .get('/api/cache/stats')
        .expect(200);

      expect(statsResponse.body).toHaveProperty('connected_clients');
      expect(statsResponse.body).toHaveProperty('total_keys');

      // 3. Try to clear cache as user (should fail)
      await request(app)
        .delete('/api/cache/clear')
        .set('Authorization', `Bearer ${userToken}`)
        .expect(403);

      // 4. Clear cache as admin
      await request(app)
        .delete('/api/cache/clear')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);
    });
  });

  describe('Export Flow', () => {
    it('should handle complete export flow', async () => {
      // 1. Get export options
      const optionsResponse = await request(app)
        .get('/api/export/customers/options')
        .set('Authorization', `Bearer ${userToken}`)
        .expect(200);

      expect(optionsResponse.body).toHaveProperty('filters');
      expect(optionsResponse.body).toHaveProperty('fields');

      // 2. Export data
      const exportResponse = await request(app)
        .post('/api/export/customers/csv')
        .set('Authorization', `Bearer ${userToken}`)
        .send({
          filters: {
            dateRange: {
              start: '2024-01-01',
              end: '2024-12-31'
            },
            status: ['Active']
          },
          fields: optionsResponse.body.fields
        })
        .expect(200);

      expect(exportResponse.headers['content-type']).toContain('text/csv');
      expect(exportResponse.headers['content-disposition']).toContain('customers_export_');
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid routes', async () => {
      await request(app)
        .get('/api/invalid/route')
        .expect(404);
    });

    it('should handle malformed requests', async () => {
      await request(app)
        .post('/api/tokens/check')
        .send({ estimatedTokens: 'invalid' })
        .expect(400);
    });

    it('should handle service errors', async () => {
      TokenManager.prototype.getUsageStats.mockRejectedValue(new Error('Service error'));

      await request(app)
        .get('/api/tokens/stats')
        .expect(500);
    });
  });

  describe('Rate Limiting', () => {
    it('should handle rate limiting', async () => {
      const requests = Array(11).fill().map(() =>
        request(app)
          .get('/api/tokens/stats')
      );

      const responses = await Promise.all(requests);

      // Assuming rate limit is 10 requests per minute
      expect(responses[10].status).toBe(429);
    });
  });
}); 